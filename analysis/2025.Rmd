---
title: "Log 2025"
output:
  workflowr::wflow_html:
    toc: true
    toc_depth: 5
    mathjax: local
    code_folding: hide
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.show = 'asis', include = T, eval = T, warning = F)
```


```{css style settings, echo = FALSE}
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    font-size: 14px;
    border-left: 5px solid #eee;
}
```

## Core Gene Discovery

### 1. some term definitions and descriptions 
- **Perturbation**: A change to the genome of a cell carried out by the CRISPR-Cas9 system or one of its variants. Common perturbations include CRISPRko (knockout via nuclease-active Cas9), CRISPRi (inactivation via dCas9 tethered to a repressive domain), CRISPRa (activation via dCas9 tethered to an activating domain).

- **gRNA**: An RNA guiding the Cas9 to its target in order to perturb it.

- **Target**: The genomic element targeted by a gRNA, including gene TSS, enhancer. Typically, mulitple gRNAs are designed to perturb one given target. 

- **Targeting gRNA**: A gRNA that is intended to perturb a genomic target.

- **Non-targeting gRNA**: A gRNA which maps to a location whose perturbation is known to have no effect on target gene. In general, we treat Non-targeting gRNAs negative controls.

- **Response**: A molecular readout (gene expression) in the single-cell CRISPR screen, which is the response of perturbation of interest.

- **Multiplicity of infection (MOI)**: The MOI of a CRSIPR screen can be categorized as low or high and also can also be numerically quantified. A high MOI dataset is the experiment that aims to insert multiple gRNAs into each cell. A low MOI dataset aims to insert a single gRNA into each cell. The MOI reflects the average of gRNAs delivered per cell. if MOI of 10 means that on average each cell was infected by 10 gRNAs.

**some descriptions of sceptre**:

main task is "Does perturbing a target impact a response?"

- **Target-response pair**: A pair consisting of a target and a response.For example, a target-response pair could be a specific enhancer coupled to a specific gene. Each target-response pair corresponds to a hypothesis to be tested: Does perturbing the target impact the response?

- **Negative control pair**: A target-response pair in which the target consits of one or more non-targeting gRNAs. Negative control pairs are used to assess the calibration of a statistical analysis method.

- **Positive control pair**: A target-response pair in which the target is a genomic element such as enhancer or gene known to have an effect on the response. Positive control pairs are used to assess the power of a statistical analysis method.

- **Cis pair**: A kind of discovery target-response pair in which the target and response are located in close proximity on the same chromosome.

- **Trans pair**: A a kind of discovery target-response pair for which the target and response are not necessarily located in close proximity or on the same chromosome as one another.

## July 19

- what I did
  - exploring some mechanisms of sceptre package
  - comparing NTC guides's results between sceptre and limma
  - run trans analysis of Replogle et al K562 KD8 genome-wide perturb-seq (gwps) dataset

### 1. some mechanisms of sceptre package

#### **1.1 construct cis gRNA_target-response pairs:**

Why dose sceptre exclude all pairs containing each positive control gRNA target from the cis pairs when using `construct_cis_pairs(sceptre_object, positive_control_pairs = pc_pairs, distance_threshold = 5e6)`?

> sceptre authors' thought: a gRNA target used for a positive control pair is a known biological effector. Its purpose is to produce a large and predictable effect. Including this gRNA target's pairs in the discovery analysis, such as gRNA-other gene (A, B) pairs, violates the purpose of the discovery analysis. The analysis of these additional pairs is no longer a pure exploration of novel cis-regulatory relationships, but an analysis of the pleiotropic or off-target effects of a known, powerfull perturbation.

>In statistics, **1) contaminating the Null Distribution**: If a positive control gRNA target is included in the analysis, its strong effect on its target gene (and potentially other genes) will compromise the whole resampleing process. The null distribution will be generated by resampling a powerfull biological effector, which can make the variance of null distribution inflated. The simulation of the null hypothesis would be contaminated by a non-null reality. **2) Distorting the FDR**: FDR depends on the overall p-value distribution of test. if we include a set of known, extremely significant p-values from positive control targets (whose p-values may be close to zero) in this distribution will be distorted.


#### **1.2 calibration mechanism**

In the calibration step, sceptre samples groups of non-targeting gRNAs to calibrate. The idea is to get enough NTC gRNA target-response pairs to check whether the test is well calibrated. It also depends on the number of qc passed discovery pairs (here is cis pairs). It follows this equation:


$$
\text{n_NTC_gRNAs}= 
  \frac{ \text{MULT_FACTOR} \times \text{n_calibration_pairs} }
       { \text{p_hat} \times \text{n_genes} }
$$


We set MULT_FACTOR to 5 as a redundancy factor.

p_hat represents the estimated probability that an NTC gRNA–gene pair is valid, which is 0.96 in our case.

The total number of genes (n_genes) is 7,991.

For n_calibration_pairs, we ranged it from 101,920 (the real number of cis pairs) up to 1,000,000 so that all NTC gRNAs could be covered.

code below is my simulation result:
```{r,warning=F}
suppressPackageStartupMessages(library(tidyverse))
suppressPackageStartupMessages(library(scales))

compute_n_grna_groups <- function(n_calibration_pairs,
                                  n_genes = 7991,
                                  p_hat = 0.96,
                                  N_POSSIBLE_GROUPS_THRESHOLD = 100L,
                                  n_possible_groups = 514L,
                                  MULT_FACTOR = 5) {
  raw <- ceiling(MULT_FACTOR * n_calibration_pairs / (p_hat * n_genes))
  lower <- pmax(raw, N_POSSIBLE_GROUPS_THRESHOLD)
  out <- ifelse(lower >= n_possible_groups, n_possible_groups, lower)
  as.integer(out)
}

p_hat <- 0.96
n_genes <- 7991
N_POSSIBLE_GROUPS_THRESHOLD <- 100L
n_possible_groups <- 514L
MULT_FACTOR <- 5

lower <- N_POSSIBLE_GROUPS_THRESHOLD * p_hat * n_genes / MULT_FACTOR
upper <- n_possible_groups * p_hat * n_genes / MULT_FACTOR

x_vals <- seq(101920, 1100000, by = 5000)

dat <- data.frame(n_calibration_pairs = x_vals)
dat$n_grna_groups <- compute_n_grna_groups(
  dat$n_calibration_pairs,
  n_genes = n_genes,
  p_hat = p_hat,
  N_POSSIBLE_GROUPS_THRESHOLD = N_POSSIBLE_GROUPS_THRESHOLD,
  n_possible_groups = n_possible_groups,
  MULT_FACTOR = MULT_FACTOR
)

p <- ggplot(dat, aes(x = n_calibration_pairs, y = n_grna_groups)) +
  geom_line(linewidth = 1) +
  geom_hline(yintercept = N_POSSIBLE_GROUPS_THRESHOLD, linetype = 2) + # 上下限
  geom_hline(yintercept = n_possible_groups, linetype = 2) +
  geom_vline(xintercept = lower, linetype = 3) +
  geom_vline(xintercept = upper, linetype = 3) +
  annotate("text", x = lower, y = N_POSSIBLE_GROUPS_THRESHOLD + 20,
           label = sprintf("lower ≈ %.0f", lower), angle = 90, vjust = -0.5, hjust = 0) +
  annotate("text", x = upper, y = n_possible_groups - 20,
           label = sprintf("upper ≈ %.0f", upper), angle = 90, vjust = 1.1, hjust = 1) +
  labs(
    x = "n_calibration_pairs",
    y = "n_grna_groups",
    title = "p_hat=0.96, n_genes=7991",
  ) +
  scale_y_continuous(breaks = c(100, 200, 300, 400, 514)) +
  scale_x_continuous(labels = label_number()) +
  theme_classic(base_size = 13)

print(p)
```


### 2. Comparison of NTC gRNA alibration between sceptre and limma

We compared calibration results of non-targeting gRNAs between limma and sceptre by aligning shared ntc gRNA–gene pairs (~1M) and visualizing overlap with Venn diagrams, QQ plots, and scatter plots to assess concordance and differences in significance.

In sceptre analysis, we manually set `n_calibration_pairs = 1000000`, which included all 514 NTC gRNAs in the calibration. On average, each NTC gRNA was paired with 1,946 genes as target–response pairs. We totally found 24 significant ntc gRNA pairs at alpha=0.1.

In the limma analysis, every NTC gRNA was paired with the entire set of genes without any restriction.
So we obtained 1000,000 shared ntc gRNA pairs.


```{r out.width="50%", fig.cap="venn diagram of shared ntc gRNA pairs"}
knitr::include_graphics("assets/2025/figure/limma_sceptre_shared_pairs.png", error = FALSE)
```


```{r out.width="49%", fig.show="hold", fig.cap="QQ plot stratified by ntc gRNAs"}
knitr::include_graphics(
  c("assets/2025/figure/limma_all_pairs_qqplot.png", 
    "assets/2025/figure/sceptre_all_pairs_qqplot.png"), error = FALSE)
```


```{r out.width="49%", fig.show="hold", fig.cap="shared pairs QQ plot and scatter plot: limma v.s sceptre"}
knitr::include_graphics(
  c("assets/2025/figure/limma_vs_sceptre_shared_pairs_qqplot.png",
    "assets/2025/figure/limma_vs_sceptre_shared_pairs_scatter_plot.png"), error = FALSE)
```



### 3. simulation of batch as continuous or categorial varibale 

**Design**:

We simulated a null setting where gene expression does not depend on batch. We generated counts for 300 batches × 20 cells per batch from Poisson(μ = 10). For each replicate (500 in total) we fit three glm regressons:

1. y ~ 1 (intercept-only, the true model)

2. y ~ batch with batch as continuous 

3. y ~ factor(batch) with batch as categorical

From each Poisson fit we took the fitted means \mu and then estimated the NB size parameter \theta . I calculated residual deviance/df, \theta, and RMSE between \mu and true \mu .

**Results**: Across 50 replicates, all three models had deviance/df = 1 and very large \theta, suggesting that near-Poisson residuals and no material overdispersion. the p value of \beta in numeric model was with an approximately uniform p-value distribution. For mean estimation, the value of intercept-only is similar with the value of numeric model (small RMSE), but factor had a much larger RMSE. I guess it fits a separate mean per batch from small per-batch sample sizes (only 20 cells).

```{r warning=F}
set.seed(1)
NSIM  <- 500
N_BATCH <- 300
CELLS_PER_BATCH <- 20 #每批细胞数量(均衡)
MU_TRUE <- 10 # 各批次真实均值（完全相同）
THETA_CAP <- 1000 # theta上限 sceptre setting is 1000
THETA_LO  <- 1e-2 # theta下限


library(MASS) # theta.md
library(tidyverse)
library(patchwork)
library(scales)

# helper function to estimate theta
theta_est <- function(y, mu, dfr, cap = THETA_CAP, lo = THETA_LO) {
  # th_list <- sceptre:::estimate_theta(
  #   y = y, mu = mu, dfr = dfr,
  #   limit = 50, eps = (.Machine$double.eps)^(1/4)
  # )
  # th <- th_list[[1]]
  # th <- max(min(th, cap), lo)
  # th
  
  th <- tryCatch(MASS::theta.md(y, mu, dfr), error = function(e) NA_real_)
  th <- max(min(th, cap), lo)
  th
}

# one time simulation
# real: 各批次间无差异，即同均值。
# aim: 此时若把batch加入到协变量中作为连续性变量，是否会使poisson 估计的mu有偏？

fit_once_equal_mu <- function(n_batch = N_BATCH, cells_per_batch = CELLS_PER_BATCH, mu_true = MU_TRUE) {
  # 构造均衡批次
  batch <- rep(seq_len(n_batch), each = cells_per_batch)
  
  # 真实情况：所有批次均值完全相同
  y <- rpois(length(batch), lambda = mu_true)
  dat <- data.frame(y = y, batch = batch)
  
  # A) 真模型：截距-only
  m_int  <- glm(y ~ 1, data = dat, family = poisson())
  mu_int <- fitted(m_int)
  th_int <- theta_est(dat$y, mu_int, df.residual(m_int))
  out_int <- tibble(
    model   = "Intercept-only (true)",
    theta   = th_int,
    dev     = deviance(m_int),
    df      = df.residual(m_int),
    dev_df  = dev / df,
    beta    = NA_real_, se_beta = NA_real_, z_beta = NA_real_, p_beta = NA_real_,
    RMSE_mu = sqrt(mean((mu_int - mu_true)^2))
  )
  
  # B) 把 batch 当作连续
  m_num  <- glm(y ~ batch, data = dat, family = poisson())
  mu_num <- fitted(m_num)
  th_num <- theta_est(dat$y, mu_num, df.residual(m_num))
  co <- coef(summary(m_num))
  beta_hat <- unname(co[2, "Estimate"])
  se_hat <- unname(co[2, "Std. Error"])
  z_hat <- unname(co[2, "z value"])
  p_hat <- unname(co[2, "Pr(>|z|)"])
  out_num <- tibble(
    model   = "Numeric (batch as continuous)",
    theta   = th_num,
    dev     = deviance(m_num),
    df      = df.residual(m_num),
    dev_df  = dev / df,
    beta    = beta_hat, se_beta = se_hat, z_beta = z_hat, p_beta = p_hat,
    RMSE_mu = sqrt(mean((mu_num - mu_true)^2))
  )
  
  # C) 把 batch 当作因子 or dummy matrix
  m_fac  <- glm(y ~ factor(batch), data = dat, family = poisson())
  mu_fac <- fitted(m_fac)
  th_fac <- theta_est(dat$y, mu_fac, df.residual(m_fac))
  out_fac <- tibble(
    model = "Factor (batch as categorical)",
    theta = th_fac,
    dev = deviance(m_fac),
    df = df.residual(m_fac),
    dev_df = dev / df,
    beta = NA_real_, se_beta = NA_real_, z_beta = NA_real_, p_beta = NA_real_,
    RMSE_mu = sqrt(mean((mu_fac - mu_true)^2))
  )
  
  bind_rows(out_int, out_num, out_fac)
}

NSIM <- 50
res <- bind_rows(replicate(NSIM, fit_once_equal_mu(), simplify = FALSE)) %>%
  group_by(model) %>% mutate(sim = row_number()) %>% ungroup()

summ <- res %>%
  group_by(model) %>%
  summarise(
    SIM_n = n(),
    mean_dev_df = mean(dev_df, na.rm = TRUE),
    sd_dev_df = sd(dev_df,   na.rm = TRUE),
    median_theta = median(theta, na.rm = TRUE),
    prop_theta_cap = mean(theta >= THETA_CAP, na.rm = TRUE),
    mean_RMSE_mu = mean(RMSE_mu, na.rm = TRUE),
    .groups = "drop"
  )

kableExtra::kable(summ)
```


### trans analysis

```{r warning=F}
library(arrow)
library(duckplyr)

# db <- open_dataset('/project/xuanyao/qilong/Project/Core_Gene_Programs/Johnathan/sceptre/K562_gwps_all_in_one/sceptre_outputs_trans/trans_results/')
# write_parquet(db, '/project/xuanyao/qilong/Project/Core_Gene_Programs/Johnathan/sceptre/K562_gwps_all_in_one/sceptre_outputs_trans/Reploge_2022_Cell_K562_gwps_KD8_all_trans_results.parquet')

db <- read_parquet_duckdb('/project/xuanyao/qilong/Project/Core_Gene_Programs/Johnathan/sceptre/K562_gwps_all_in_one/sceptre_outputs_trans/Reploge_2022_Cell_K562_gwps_KD8_all_trans_results.parquet')

tmp <- db %>% filter(response_id=='ENSG00000206172' & pass_qc == T & grna_target == 'ENSG00000105610') 

kableExtra::kable(tmp)

```




